**üß© Architecture Overview**

This Proof of Concept demonstrates an end-to-end AI-driven shopping experience built using MCP UI, OpenAI, and a Remote DOM rendering pipeline.
The system dynamically generates UI layouts and product results using an LLM, then renders them safely inside a React application.


**Core Components**

**1. MCP UI Client (@mcp-ui/client)**

The MCP UI Client is used inside the React application to render UI that is generated dynamically by the server.
Key features:

Renders UI Resources using <UIResourceRenderer />

Supports Remote DOM, where DOM nodes are defined by the server or LLM

Maps custom remote DOM elements (e.g., <shop-card>, <shop-text>, <shop-img>) to React components

Handles remote events using onUIAction (e.g., addToCart, removeFromCart)

This allows complex UI to be constructed at runtime without shipping UI code from server to client.

**Resource Renderer**
The UI Resource is rendered in the <UIResourceRenderer /> component. It automatically detects the resource type and renders the appropriate component.
It accepts the following props:

	 	<UIResourceRenderer
	                    key={resource.uri}
	                    resource={resource}
	                    onUIAction={handleToolAction}
	                    remoteDomProps={{
	                      library: shoppingComponentLibrary,
	                      remoteElements: shoppingRemoteElements,
	                    }}
	                  />

`resource`: The resource object from an MCP Tool response. It must include uri, mimeType, and content (text, blob)

`onUIAction`: Optional callback for handling UI actions from the resource

`remoteDomProps`: Optional props for the internal <RemoteDOMResourceRenderer>

`library`: React component library for Remote DOM resources

`remoteElements`: remote element definitions for Remote DOM resources.



**2. MCP UI Server (@mcp-ui/server)**

The backend uses MCP UI Server utilities to create UI resources that the frontend can render.
Responsibilities:

Wrap generated Remote DOM scripts using createUIResource()

Provide consistent encoding and metadata

Integrate seamlessly with the MCP UI Client

The server does not send HTML‚Äîit sends instructions that the frontend renders through the Remote DOM layer.

**Create UI Resource**

The primary payload returned from the server to the client is the UIResource:

	createUIResource({
      uri: `ui://cart/${Date.now()}`,
      content: {
        type: 'remoteDom',
        script: script,
        framework: 'react'
      },
      encoding: 'text'
    });
	
`uri`: Unique identifier for caching and routing

`type`: UI resources type

`script`: Remote dom script + data as JavaScript variables

`framework`: Custom component UI library developed in React

`encoding`: 'text' or 'blob' if encoded content




**üåê Remote DOM**

Remote DOM is the foundation of the dynamic UI.
Instead of sending HTML or JSX, the server (and LLM) sends a JavaScript script that executes inside a sandboxed environment and constructs a virtual DOM tree using custom elements like:

`<shop-card>`

`<shop-text>`

`<shop-small-text>`

`<shop-img>`

`<shop-badge>`

`<shop-grid>`

Each element corresponds to a React component implemented in a Remote DOM Component Library.

Event handlers inside the script dispatch CustomEvents, which the client maps to onUIAction events for the React app to respond to.

This enables fully generated UI layouts such as product search results, cart pages, etc.

**ü§ñ OpenAI Integration**

OpenAI is used in two main ways:

**A. Product generation**

OpenAI synthesizes realistic product datasets:

	`name`
	`description`
	`price`
	`currency`
	`imageUrl`
	`tags`
These products are inserted into Postgres so future searches use semantic retrieval.

**B. Remote DOM UI generation**

OpenAI generates the JavaScript Remote DOM script that describes how the UI should look for:

search results page

cart page

wishlist page

This script is cached in Postgres to avoid repeated LLM calls.

The system combines:

LLM reasoning ‚Üí UI layout

LLM creativity ‚Üí product generation

deterministic business logic ‚Üí cart/wishlist updates

**üóÑÔ∏è PostgreSQL**

Postgres serves as the core persistent storage layer.
Tables include:

products

Stores all product metadata generated by OpenAI or searched via vector store.

cart_items & wishlist_items

Maintain user-specific shopping state:

products in cart

quantity

wishlist items

originating search prompt

remote_dom_cache

Caches LLM-generated remote DOM scripts so the UI does not require repeated calls to OpenAI.

Postgres ensures consistency, uniqueness, and structural integrity of the data model.


**üöÄ End-to-End Flow Summary**

User searches ‚Üí React app calls /search

OpenAI generates new products

Server requests OpenAI to create a Remote DOM script

Script is cached in Postgres

Server returns a UIResource

React renders it using MCP UI Client + Remote DOM library

User actions (add/remove) trigger remote events

Server updates Postgres accordingly

Cart/Wishlist screens are also generated by LLM Remote DOM



**Server API**

http://localhost:8082/search

	Step 1: Search for relevant products
	Step 2: Try to load cached remote DOM script (from PostgreSQL)
	Step 3: If not available, then ask LLM to generate Remote DOM JS ONLY
	Step 4: Store script in DB prepared by LLM
	Step 5: Combine the Product searched and the script into the final script
	Step 6: Wrap the final script in the MCP-UI resource and respond

http://localhost:8082/cart-ui

	Step 1: Find cart and wishlist items from the database
	Step 2: Try to load cached remote DOM script (from PostgreSQL)
	Step 3: If not available, then ask LLM to generate Remote DOM JS ONLY
	Step 4: Store the script in the DB prepared by LLM
	Step 5: Combine cart and wishlist items and script into the final script
	Step 6: Wrap the final script in the MCP-UI resource and respond





**Postgres SQL Queries**


	CREATE TABLE IF NOT EXISTS remote_dom_cache (
	  id SERIAL PRIMARY KEY,
	  cache_key TEXT NOT NULL UNIQUE,     
	  script TEXT NOT NULL,
	  model TEXT,
	  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
	);

	CREATE UNIQUE INDEX IF NOT EXISTS idx_remote_dom_cache_key
	  ON remote_dom_cache (cache_key);
  
  
	CREATE TABLE IF NOT EXISTS cart_items (
	  id SERIAL PRIMARY KEY,
	  user_id TEXT NOT NULL,
	  product_id TEXT NOT NULL,
	  from_prompt TEXT,
	  qty INTEGER NOT NULL DEFAULT 1,
	  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
	  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
	);

	CREATE INDEX IF NOT EXISTS idx_cart_items_user_id
	  ON cart_items (user_id);


	CREATE TABLE IF NOT EXISTS wishlist_items (
	  id SERIAL PRIMARY KEY,
	  user_id TEXT NOT NULL,
	  product_id TEXT NOT NULL,
	  from_prompt TEXT,
	  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
	);

	CREATE INDEX IF NOT EXISTS idx_wishlist_items_user_id
	  ON wishlist_items (user_id);
  
  
  
	CREATE TABLE IF NOT EXISTS products (
	  id TEXT PRIMARY KEY,
	  name TEXT NOT NULL,
	  description TEXT,
	  price INTEGER NOT NULL,      
	  currency TEXT NOT NULL,
	  image_url TEXT,
	  tags TEXT[],
	  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
	  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
	);

-- Link to products table (optional but recommended)

	ALTER TABLE cart_items
	  ADD CONSTRAINT fk_cart_items_product
	  FOREIGN KEY (product_id) REFERENCES products(id);

-- Ensure one row per (user, product)

	CREATE UNIQUE INDEX IF NOT EXISTS idx_cart_items_user_product
	  ON cart_items (user_id, product_id);
  
  
	ALTER TABLE wishlist_items
	  ADD CONSTRAINT wishlist_items_user_product_unique
	  UNIQUE (user_id, product_id);
  
-- Link to products table (optional but recommended)

	ALTER TABLE wishlist_items
	  ADD CONSTRAINT fk_wishlist_items_product
	  FOREIGN KEY (product_id) REFERENCES products(id);
